/** Global variables used outside functions **/
// Constants
// String VAR_WITHOUT_FIELD = 'original value1'

// Variables
String gradleCmd = 'gradle --no-daemon --console=plain'  // Always include --no-daemon
String packageVersion = ''
pipeline {
  agent {
    kubernetes {
      defaultContainer 'gradle'
      // Method 1: Use plain Pod template text
      // yaml """
      //   apiVersion: v1
      //   kind: Pod
      //   spec:
      //     serviceAccountName: jenkins-sa
      //     # ... Copy/Paste full gradle_pod.yaml
      // """
      // Method 2: Use external YAML + merge dynamic spec
      yamlFile './jenkinsfiles/agents/k8s_templates/gradle_pod.yaml' // Fetched from SCM Git repo
    }
  }

  // triggers {
  //   pollSCM 'H/5 * * * *'
  // }

  options {
    // disableConcurrentBuilds()
    buildDiscarder(logRotator(daysToKeepStr: '30', artifactDaysToKeepStr: '1'))
    timestamps()
    timeout(time: 5, unit: 'MINUTES')
  }

  environment {
    PROJECT_DIR = "${WORKSPACE}"
    GRADLE_PROJECT = "${PROJECT_DIR}/gradle_project"
    PACKAGE_NAME = 'gradle_project'
    // Point Gradle to use workspace-specific settings
    GRADLE_USER_HOME = "${WORKSPACE}/.gradle"
    GRADLE_PROPERTIES = "${GRADLE_USER_HOME}/gradle.properties"
  }

  parameters {
    booleanParam(
      name: 'CHECKOUT_REPO',
      defaultValue: false,
      description: 'Enable extra stage to checkout repo if not using "Pipeline sript from SCM" config'
    )
  }
  
  stages {
    stage('Manual Repo Checkout') { // Or use "Pipeline sript from SCM"
      when { expression { params.CHECKOUT_REPO } }
      steps {
        // Install Git in runtime or in agent Dockerfile
        checkout([
          $class: 'GitSCM',
          branches: [[ name: '*/master' ]],
          // branches: [[name: "FETCH_HEAD"]],
          userRemoteConfigs: [[
            url: 'https://github.com/cv47522/jenkins-101.git',
            // credentialsId: 'my-github'
          ]]
        ])

        // Or git clone only recent 5 commits:
        // sh '''
        //   git init .
        //   git pull --depth=5 https://github.com/cv47522/jenkins-101.git master
        // '''
      }
    }

    stage('Network Debug') {
      steps {
        container('gradle') {
          sh """
            echo "=== Network Diagnostics ==="
            echo "DNS Resolution:"
            nslookup plugins.gradle.org || echo "DNS resolution failed"
            
            echo "Proxy Environment:"
            env | grep -i proxy || echo "No proxy environment variables"
            
            echo "Connectivity Test:"
            curl -I --connect-timeout 10 https://plugins.gradle.org/ || echo "Direct connection failed"
            curl -I --connect-timeout 10 --proxy ${env.HTTP_PROXY} https://plugins.gradle.org/ || echo "Proxy connection failed"
          """
        }
      }
    }

    stage('Configure Gradle Proxy') {
      steps {
        script {
          // Create CI-optimized configuration
          writeFile file: GRADLE_PROPERTIES, text: """
org.gradle.daemon=false
org.gradle.parallel=false
org.gradle.jvmargs=-Xmx512m
systemProp.http.proxyHost=${env.PROXY_IP}
systemProp.http.proxyPort=${env.PROXY_PORT}
systemProp.https.proxyHost=${env.PROXY_IP}
systemProp.https.proxyPort=${env.PROXY_PORT}
""".trim()
        }
      }
    }

    stage('Get Package Version') {
      steps {
        script {
          dir(GRADLE_PROJECT) {
            // Decide which Gradle command to use
            // gradleCmd = !fileExists('./gradlew') ?: './gradlew --no-daemon --console=plain'
            // if (gradleCmd == './gradlew') {
            //   // Ensure the wrapper is executable
            //   sh 'chmod +x ./gradlew'
            // }

            // Run the properties task quietly, extract the "version" line
            packageVersion = sh(script: "${gradleCmd} properties -q | grep '^version:' | awk '{print \$2}'",
              returnStdout: true).trim()
            echo "Resolved ${PACKAGE_NAME} Gradle Package Version: ${packageVersion}"
            currentBuild.displayName = "${PACKAGE_NAME}-${packageVersion}/${BUILD_NUMBER}"
          }
        }
      }
    }

    stage('Build') {
      steps {
        script {
          container('gradle') {
            dir(GRADLE_PROJECT) {
              echo "------------ Building with: ${gradleCmd} ------------"
              sh """
                ls -l
                java -version
                javac -version
                ${gradleCmd} -v
                ${gradleCmd} clean compileJava --info
                ls -l ./app/build/
              """
            }
          }
        }
      }
    }

    stage('Test') {
      steps {
        dir(GRADLE_PROJECT) {
          echo "------------ Testing ------------"
          sh """
            ${gradleCmd} test
          """
        }
      }
    }

    stage('Package') {
      steps {
        dir(GRADLE_PROJECT) {
          echo "------------ Packaging ------------"
          sh """
            ${gradleCmd} jar
            ls -l ./app/build/libs
          """
        }
      }
    }

    stage('Deploy') {
      steps {
        dir(GRADLE_PROJECT) {
          echo "------------ Deploying ------------"
          sh """
            ${gradleCmd} publish --info
            ls -l ./build/localrepo/com/example/app
          """
        }
      }
    }
  }

  post {
    always {
      dir(GRADLE_PROJECT) {
        // For simple APP, Archive artifacts got from Gradle build library created by: $ ./gradlew build
        // archiveArtifacts artifacts: '**/build/libs/*.jar', fingerprint: true

        // For complex APP, Archive artifacts got from local Maven repo created by: $ ./gradlew build publish
        archiveArtifacts artifacts: 'build/localrepo/**/*.jar, build/localrepo/**/*.pom', fingerprint: true
      }
      cleanWs()
    }
  }
}